/* Automatically generated nanopb header */
/* Generated by nanopb-0.4.8 at Tue Feb 24 22:15:26 2026. */

#ifndef PB_WS_SENSOR_SENSOR_PB_H_INCLUDED
#define PB_WS_SENSOR_SENSOR_PB_H_INCLUDED
#include <pb.h>

#if PB_PROTO_HEADER_VERSION != 40
#error Regenerate this file with the current version of nanopb generator.
#endif

/* Enum definitions */
/* *
 Type allows us determine what types of units the sensor uses, etc. */
typedef enum _ws_sensor_Type {
    ws_sensor_Type_T_UNSPECIFIED = 0, /* * Sensor value type which is not defined by this list, "Raw Value: {value}". */
    ws_sensor_Type_T_ACCELEROMETER = 1, /* * Acceleration, in meter per second per second, "{value}m/s/s". */
    ws_sensor_Type_T_MAGNETIC_FIELD = 2, /* * Magnetic field strength, in micro-Tesla, "{value}µT". */
    ws_sensor_Type_T_ORIENTATION = 3, /* * Orientation angle, in degrees, "{value}°". */
    ws_sensor_Type_T_GYROSCOPE = 4, /* * Angular rate, in radians per second, "{value}rad/s". */
    ws_sensor_Type_T_LIGHT = 5, /* * Light-level, non-unit-specific (For a unit-specific measurement, see: Lux),
"Raw Value: {value}". */
    ws_sensor_Type_T_PRESSURE = 6, /* * Pressure, in hectopascal, , "{value}hPa". */
    ws_sensor_Type_T_PROXIMITY = 8, /* * Distance from an object to a sensor, non-unit-specific, "Raw Value: {value}". */
    ws_sensor_Type_T_GRAVITY = 9, /* * Metres per second squared, "{value}m/s^2". */
    ws_sensor_Type_T_LINEAR_ACCELERATION = 10, /* * Acceleration not including gravity, in meter per second squared, "{value}m/s^2". */
    ws_sensor_Type_T_ROTATION_VECTOR = 11, /* * An angle in radians, "{value} rad". */
    ws_sensor_Type_T_RELATIVE_HUMIDITY = 12, /* * in percent (%), "{value}%". */
    ws_sensor_Type_T_AMBIENT_TEMPERATURE = 13, /* * Temperature of the air around a sensor, in degrees Celsius, "{value}°C". */
    ws_sensor_Type_T_OBJECT_TEMPERATURE = 14, /* * Temperature of the object a sensor is touching/pointed at, in degrees Celsius, "{value}°C". */
    ws_sensor_Type_T_VOLTAGE = 15, /* * Volts, "{value}V". */
    ws_sensor_Type_T_CURRENT = 16, /* * Milliamps, "{value}mA". */
    ws_sensor_Type_T_COLOR = 17, /* * Values are in 0..1.0 RGB channel luminosity and 32-bit RGBA format. "Color: {value}". */
    ws_sensor_Type_T_RAW = 18, /* * Sensor reads a value which is not defined by this list, "Raw Value: {value}". */
    ws_sensor_Type_T_PM10_STD = 19, /* * Standard Particulate Matter 1.0, in ppm, "{value}ppm". */
    ws_sensor_Type_T_PM25_STD = 20, /* * Standard Particulate Matter 2.5, in ppm, "{value}ppm". */
    ws_sensor_Type_T_PM100_STD = 21, /* * Standard Particulate Matter 100, in ppm, "{value}ppm". */
    ws_sensor_Type_T_PM10_ENV = 22, /* * Environmental Particulate Matter 1.0, in ppm, "{value}ppm". */
    ws_sensor_Type_T_PM25_ENV = 23, /* * Environmental Particulate Matter 2.5, in ppm, "{value}ppm". */
    ws_sensor_Type_T_PM100_ENV = 24, /* * Environmental Particulate Matter 100, in ppm, "{value}ppm". */
    ws_sensor_Type_T_CO2 = 25, /* * Measured CO2, in ppm, "{value}ppm". */
    ws_sensor_Type_T_GAS_RESISTANCE = 26, /* * Proportional to the amount of VOC particles in the air, in Ohms, "{value}Ω". */
    ws_sensor_Type_T_ALTITUDE = 27, /* * Values are in meters (m), "${$v} m". */
    ws_sensor_Type_T_LUX = 28, /* * Light level, in lux, "Lux: {value}". */
    ws_sensor_Type_T_ECO2 = 29, /* * equivalent/estimated CO2 in ppm (estimated from some other measurement), "{value}ppm". */
    ws_sensor_Type_T_UNITLESS_PERCENT = 30, /* * Percentage, unit-less, "{value}%". */
    ws_sensor_Type_T_AMBIENT_TEMPERATURE_FAHRENHEIT = 31, /* * Temperature of the air around a sensor, in degrees Fahrenheit, "{value}°F". */
    ws_sensor_Type_T_OBJECT_TEMPERATURE_FAHRENHEIT = 32, /* * Temperature of the object a sensor is touching/pointed at, in Fahrenheit, "{value}°F". */
    ws_sensor_Type_T_VOC_INDEX = 33, /* * Values are an index from 1-500 with 100 being normal, "${$v} VOC". */
    ws_sensor_Type_T_NOX_INDEX = 34, /* * Values are an index from 1-500 with 100 being normal, "${$v} NOx". */
    ws_sensor_Type_T_TVOC = 35, /* * Values are in parts per billion (ppb), "${$v} ppb". */
    ws_sensor_Type_T_BYTES = 36, /* * Values are in bytes, "${$v} bytes". */
    ws_sensor_Type_T_BOOLEAN = 37 /* * Values are boolean, "Boolean Value: ${$v}". */
} ws_sensor_Type;

/* Struct definitions */
/* *
 EventColor is used to return a sensor's color values in RGB colorspace. */
typedef struct _ws_sensor_Event_EventColor {
    float r; /* * The sensor's red channel value as a float. */
    float g; /* * The sensor's green channel value as a float. */
    float b; /* * The sensor's blue channel value as a float. */
    float a; /* * The sensor's (optional) alpha channel value as a float. */
} ws_sensor_Event_EventColor;

/* *
 Event3DVector is used to return a sensor's 3D vector values. */
typedef struct _ws_sensor_Event_Event3DVector {
    float x; /* * The sensor's x-axis value as a float. */
    float y; /* * The sensor's y-axis value as a float. */
    float z; /* * The sensor's z-axis value as a float. */
} ws_sensor_Event_Event3DVector;

/* *
 EventOrientation is used to return an orientation sensor's values. */
typedef struct _ws_sensor_Event_EventOrientation {
    float roll; /* * The sensor's roll value as a float. */
    float pitch; /* * The sensor's pitch value as a float. */
    float heading; /* * The sensor's heading value as a float. */
} ws_sensor_Event_EventOrientation;

/* *
 Event  is used to return the sensor's value and type. */
typedef struct _ws_sensor_Event {
    ws_sensor_Type type; /* * The sensor's type and corresponding SI unit */
    pb_size_t which_value;
    union {
        float float_value; /* * The sensor's value as a float. */
        pb_callback_t bytes_value; /* * The sensor's value as a byte array. */
        ws_sensor_Event_Event3DVector vector_value; /* * The sensor's 3D vector values, as floats. */
        ws_sensor_Event_EventOrientation orientation_value; /* * The sensor's orientation values, as floats. */
        ws_sensor_Event_EventColor color_value; /* * The sensor's color values, as floats. */
        bool bool_value; /* * The sensor's value, as a boolean. */
    } value;
} ws_sensor_Event;


#ifdef __cplusplus
extern "C" {
#endif

/* Helper constants for enums */
#define _ws_sensor_Type_MIN ws_sensor_Type_T_UNSPECIFIED
#define _ws_sensor_Type_MAX ws_sensor_Type_T_BOOLEAN
#define _ws_sensor_Type_ARRAYSIZE ((ws_sensor_Type)(ws_sensor_Type_T_BOOLEAN+1))

#define ws_sensor_Event_type_ENUMTYPE ws_sensor_Type





/* Initializer values for message structs */
#define ws_sensor_Event_init_default             {_ws_sensor_Type_MIN, 0, {0}}
#define ws_sensor_Event_EventColor_init_default  {0, 0, 0, 0}
#define ws_sensor_Event_Event3DVector_init_default {0, 0, 0}
#define ws_sensor_Event_EventOrientation_init_default {0, 0, 0}
#define ws_sensor_Event_init_zero                {_ws_sensor_Type_MIN, 0, {0}}
#define ws_sensor_Event_EventColor_init_zero     {0, 0, 0, 0}
#define ws_sensor_Event_Event3DVector_init_zero  {0, 0, 0}
#define ws_sensor_Event_EventOrientation_init_zero {0, 0, 0}

/* Field tags (for use in manual encoding/decoding) */
#define ws_sensor_Event_EventColor_r_tag         1
#define ws_sensor_Event_EventColor_g_tag         2
#define ws_sensor_Event_EventColor_b_tag         3
#define ws_sensor_Event_EventColor_a_tag         4
#define ws_sensor_Event_Event3DVector_x_tag      1
#define ws_sensor_Event_Event3DVector_y_tag      2
#define ws_sensor_Event_Event3DVector_z_tag      3
#define ws_sensor_Event_EventOrientation_roll_tag 1
#define ws_sensor_Event_EventOrientation_pitch_tag 2
#define ws_sensor_Event_EventOrientation_heading_tag 3
#define ws_sensor_Event_type_tag                 1
#define ws_sensor_Event_float_value_tag          2
#define ws_sensor_Event_bytes_value_tag          3
#define ws_sensor_Event_vector_value_tag         4
#define ws_sensor_Event_orientation_value_tag    5
#define ws_sensor_Event_color_value_tag          6
#define ws_sensor_Event_bool_value_tag           7

/* Struct field encoding specification for nanopb */
#define ws_sensor_Event_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, UENUM,    type,              1) \
X(a, STATIC,   ONEOF,    FLOAT,    (value,float_value,value.float_value),   2) \
X(a, CALLBACK, ONEOF,    BYTES,    (value,bytes_value,value.bytes_value),   3) \
X(a, STATIC,   ONEOF,    MESSAGE,  (value,vector_value,value.vector_value),   4) \
X(a, STATIC,   ONEOF,    MESSAGE,  (value,orientation_value,value.orientation_value),   5) \
X(a, STATIC,   ONEOF,    MESSAGE,  (value,color_value,value.color_value),   6) \
X(a, STATIC,   ONEOF,    BOOL,     (value,bool_value,value.bool_value),   7)
#define ws_sensor_Event_CALLBACK pb_default_field_callback
#define ws_sensor_Event_DEFAULT NULL
#define ws_sensor_Event_value_vector_value_MSGTYPE ws_sensor_Event_Event3DVector
#define ws_sensor_Event_value_orientation_value_MSGTYPE ws_sensor_Event_EventOrientation
#define ws_sensor_Event_value_color_value_MSGTYPE ws_sensor_Event_EventColor

#define ws_sensor_Event_EventColor_FIELDLIST(X, a_) \
X(a_, STATIC,   SINGULAR, FLOAT,    r,                 1) \
X(a_, STATIC,   SINGULAR, FLOAT,    g,                 2) \
X(a_, STATIC,   SINGULAR, FLOAT,    b,                 3) \
X(a_, STATIC,   SINGULAR, FLOAT,    a,                 4)
#define ws_sensor_Event_EventColor_CALLBACK NULL
#define ws_sensor_Event_EventColor_DEFAULT NULL

#define ws_sensor_Event_Event3DVector_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, FLOAT,    x,                 1) \
X(a, STATIC,   SINGULAR, FLOAT,    y,                 2) \
X(a, STATIC,   SINGULAR, FLOAT,    z,                 3)
#define ws_sensor_Event_Event3DVector_CALLBACK NULL
#define ws_sensor_Event_Event3DVector_DEFAULT NULL

#define ws_sensor_Event_EventOrientation_FIELDLIST(X, a) \
X(a, STATIC,   SINGULAR, FLOAT,    roll,              1) \
X(a, STATIC,   SINGULAR, FLOAT,    pitch,             2) \
X(a, STATIC,   SINGULAR, FLOAT,    heading,           3)
#define ws_sensor_Event_EventOrientation_CALLBACK NULL
#define ws_sensor_Event_EventOrientation_DEFAULT NULL

extern const pb_msgdesc_t ws_sensor_Event_msg;
extern const pb_msgdesc_t ws_sensor_Event_EventColor_msg;
extern const pb_msgdesc_t ws_sensor_Event_Event3DVector_msg;
extern const pb_msgdesc_t ws_sensor_Event_EventOrientation_msg;

/* Defines for backwards compatibility with code written before nanopb-0.4.0 */
#define ws_sensor_Event_fields &ws_sensor_Event_msg
#define ws_sensor_Event_EventColor_fields &ws_sensor_Event_EventColor_msg
#define ws_sensor_Event_Event3DVector_fields &ws_sensor_Event_Event3DVector_msg
#define ws_sensor_Event_EventOrientation_fields &ws_sensor_Event_EventOrientation_msg

/* Maximum encoded size of messages (where known) */
/* ws_sensor_Event_size depends on runtime parameters */
#define WS_SENSOR_SENSOR_PB_H_MAX_SIZE           ws_sensor_Event_EventColor_size
#define ws_sensor_Event_Event3DVector_size       15
#define ws_sensor_Event_EventColor_size          20
#define ws_sensor_Event_EventOrientation_size    15

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif
